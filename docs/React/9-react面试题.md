### 1、super() 和 super(props)区别

- 因为类组件 基于 `class` 继承 所以在 `constructor` 中必须使用 `super`，在调用 `super` 过程中 无论是否传入 `props`，`react` 内部都会将 `props` 赋值给组件实例 `props` 属性中

- 如果只调用 `super()` 那么 `this.props` 在 `constructor` 中时 `undefined`

### 2、类组件 和 函数组件区别

- 类组件 使用 `es6` 类的编写形式去编写组件 必须实现 `render` 方法 并 `return jsx `

- 函数组件 使用函数编写 `react` 必须 `return jsx`

- 区别：编写形式 状态管理 生命周期 调用方式 获取渲染的值

- 函数组件优势 语法更短、更简单 更容易开发和测试 不需要考虑 `this` 指向问题

### 3、受控组件 和 非受控组件

- 通常我们把包含“不受控制”状态的组件称为“非受控组件”。

- 相反，当组件中的重要信息是由 props 而不是其自身状态驱动时，就可以认为该组件是“受控组件”。

- 非受控组件通常很简单，因为它们不需要太多配置。但是当你想把它们组合在一起使用时，就不那么灵活了。受控组件具有最大的灵活性，但它们需要父组件使用 props 对其进行配置。

- 在实践中，“受控”和“非受控”并不是严格的技术术语——通常每个组件都同时拥有内部状态和 props。然而，这对于组件该如何设计和提供什么样功能的讨论是有帮助的。

- 当编写一个组件时，你应该考虑哪些信息应该受控制（通过 props），哪些信息不应该受控制（通过 state）。当然，你可以随时改变主意并重构代码。

### 4、react 事件机制

- `react` 自己实现了一套事件机制 包括事件注册 事件合成 事件冒泡 事件派发 统称合成事件

- 合成事件 是 `react` 对原生事件进行了一个 跨浏览器包装，如果想获取原生 `Dom` 事件 可以通过 `e.nativeEvent`

- 执行时机 由于 `react17` 之后将事件注册在当前项目 容器中 所以当冒泡到容器的时候才会执行， 冒泡阶段 先执行原生事件 等到冒泡到容器的时候在执行 合成事件


### 5、react 渲染错误捕获

- static getDerivedStateFromError()

- componentDidCatch()