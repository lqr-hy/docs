# 项目优化

### 1、speed-measure-webpack-plugin 显示打包时间

```js
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
const smp = new SpeedMeasurePlugin();

module.exports = smp.wrap({webpack options})
```

### 2、webpack-bundle-analyzer 分析包的体积

```js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin

module.exports = {
  plugins: [new BundleAnalyzerPlugin()]
}
```

### 3、friendly-errors-webpack-plugin 打包的时候错误提示

### 4、exclude/include 配置转译目录

exclude、include 配置来确保转译尽可能少的文件

- exclude 指定要排除的文件
- include 指定要包含的文件。
- exclude 的优先级高于 include，在 include 和 exclude 中使用绝对路径数组

### 5、cache-loader 和 cache

`cache`: Webpack5 中的 cache 选项允许你启用缓存来提高构建性能 将 cache 设置为 true 时，Webpack 会在构建之间缓存编译后的模块和代码块。这意味着在后续的构建中，Webpack 只会编译自上次构建以来发生更改的模块，从而大大减少构建时间。缓存存储在内存中，因此不会在文件系统上生成任何额外的文件

`cache-loader`: cache-loader 是一个单独的加载器插件，可以与 Webpack 一起使用，用于缓存昂贵的加载器操作的结果。当使用 cache-loader 时，它将在文件系统上持久缓存加载器的结果。这可以通过避免对相同输入文件重新执行昂贵的加载器来加速构建过程。

```js
module.exports = {
  cache: {
    type: 'memory' // 缓存类型 ('memory' 或 'filesystem')
  },

  module: {
    rules: [
      {
        test: /\.js$/,
        use: ['cache-loader', 'babel-loader'] // 'cache-loader'会在 'babel-loader' 之前应用
      }
    ]
  }
}
```

:::info 区别

- Webpack 5 中的 cache 选项处理 Webpack 内部的模块和代码块级别的缓存，
- cache-loader 是一个加载器，它将加载器操作的昂贵结果缓存到文件系统中，以提高构建性能
  :::

### 6、thread-loader 多进程构建

将一些耗时的 Loader 操作放到 Worker 池中，以实现多线程并行处理

```js
module.exports = {
  // ...其他Webpack配置...
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: ['thread-loader', 'babel-loader'] // 使用thread-loader将babel-loader放入Worker池中
      }
    ]
  }
}
```

### 7、terser-webpack-plugin 多进程压缩

```js
module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        test: /\.js(\?.*)?$/i
      })
    ]
  }
}
```

### 8、externals 排除依赖

```js
module.exports = {
  externals: {
    jquery: 'jQuery'
  }
}
```

### 9、splitChunks 公共代码抽离

```js
module.exports = {
  // ...其他Webpack配置...
  optimization: {
    splitChunks: {
      chunks: 'all', // 全部chunks参与代码抽取，包括入口chunks和异步加载的chunks
      minSize: 30000, // 模块大小超过30KB才抽取为公共代码
      minChunks: 1, // 模块至少被引用1次才抽取为公共代码
      maxAsyncRequests: 5, // 按需加载时并行请求的最大数量，默认为5
      maxInitialRequests: 3, // 入口点并行加载的最大数量，默认为3
      automaticNameDelimiter: '~', // 生成的公共代码chunk的名称分隔符，默认为~
      cacheGroups: {
        defaultVendors: {
          test: /[\\/]node_modules[\\/]/, // 抽取来自node_modules的模块
          priority: -10, // 优先级，数值越大，优先级越高，优先级较高的会先尝试匹配，匹配不到再尝试较低优先级的
          reuseExistingChunk: true // 如果一个模块已经被抽取为公共代码，则复用它，不再重新生成新的chunk
        },
        default: {
          minChunks: 2, // 默认情况下，模块至少被引用2次才抽取为公共代码
          priority: -20, // 优先级较低，数值较小
          reuseExistingChunk: true
        }
      }
    }
  }
}
```
:::details optimization
#### 1. **`optimization.splitChunks`**（代码分割）
`splitChunks` 配置用于将重复使用的代码（如库文件）抽离出来，避免将它们打包进每个入口文件。

```javascript
optimization: {
  splitChunks: {
    chunks: 'all', // 默认值为 'async'，还可以设置为 'all' 或 'initial'
    minSize: 30000, // 生成的块的最小大小
    maxSize: 0, // 如果设置为非 0 值，则强制将超过此值的块拆分为更小的块
    minChunks: 1, // 拆分前模块的最小重复次数
    maxAsyncRequests: 5, // 按需加载时的最大并行请求数
    maxInitialRequests: 3, // 入口点的最大并行请求数
    automaticNameDelimiter: '~', // 拆分生成的文件名的连接符
    cacheGroups: {
      vendors: {
        test: /[\\/]node_modules[\\/]/, // 提取第三方库
        priority: -10, // 优先级
        name: 'vendors' // 输出文件名
      },
      default: {
        minChunks: 2,
        priority: -20,
        reuseExistingChunk: true // 如果一个模块已经被打包过，则重复使用
      }
    }
  }
}
```

#### 2. **`optimization.minimize`**（代码压缩）
`minimize` 控制是否启用压缩，默认在生产模式下启用，在开发模式下禁用。

```javascript
optimization: {
  minimize: true, // 启用代码压缩
  minimizer: [
    new TerserPlugin({
      terserOptions: {
        compress: {
          drop_console: true, // 删除 console.log 语句
        },
      },
    }),
  ],
}
```
- `TerserPlugin` 是 Webpack 内置的压缩工具，用于压缩 JavaScript 文件。可以进一步配置压缩行为。

#### 3. **`optimization.runtimeChunk`**（运行时代码）
`runtimeChunk` 将 Webpack 的运行时代码抽离出来，以避免每次修改导致文件的哈希值变化。

```javascript
optimization: {
  runtimeChunk: {
    name: 'runtime', // 提取到一个单独的文件 'runtime.[hash].js'
  }
}
```

#### 4. **`optimization.usedExports`**（标记未使用的导出）
启用 **tree-shaking** 以剔除没有使用的模块。

```javascript
optimization: {
  usedExports: true, // 只导出使用到的模块，依赖于 ES6 模块语法
}
```

#### 5. **`optimization.sideEffects`**（剔除无副作用的代码）
可以通过 `package.json` 中的 `sideEffects` 字段配合使用，来删除那些标记为无副作用的模块。

```javascript
optimization: {
  sideEffects: true // 剔除被标记为无副作用的模块
}
```

#### 6. **`optimization.concatenateModules`**（作用域提升）
启用 **scope hoisting**，即将多个模块合并到一个函数中执行，减少包的体积和运行时开销。

```javascript
optimization: {
  concatenateModules: true, // 默认为 true，提升模块作用域
}
```

#### 7. **`optimization.moduleIds`** 和 **`chunkIds`**（模块和块 ID 优化）
- `moduleIds`: 控制模块 ID 的生成方式，常见值有 `natural`、`named`、`hashed`、`deterministic`。
- `chunkIds`: 控制块 ID 的生成方式，类似于 `moduleIds`，常见值有 `natural`、`named`、`deterministic`。

```javascript
optimization: {
  moduleIds: 'deterministic', // 在内容不变的情况下，模块 ID 不会改变
  chunkIds: 'deterministic', // 在内容不变的情况下，块 ID 不会改变
}
```

#### 8. **`optimization.noEmitOnErrors`**（跳过生成有错误的模块）
当构建出现错误时，设置为 `true` 可以跳过生成错误的模块，这样生成的包不会包含错误。

```javascript
optimization: {
  noEmitOnErrors: true // 发生错误时不生成代码包
}
```

#### 9. **`optimization.mangleWasmImports`**（WebAssembly 压缩）
启用对 WebAssembly (WASM) 导入的混淆，减少包大小。

```javascript
optimization: {
  mangleWasmImports: true // 混淆 WASM 的导入
}
```

#### 10. **`optimization.removeAvailableModules`** 和 **`optimization.removeEmptyChunks`**
- `removeAvailableModules`: 从 chunk 中移除已打包到父 chunk 中的模块。
- `removeEmptyChunks`: 移除所有空的 chunk。

```javascript
optimization: {
  removeAvailableModules: true, // 移除重复的模块
  removeEmptyChunks: true // 移除空的 chunk
}
```
:::