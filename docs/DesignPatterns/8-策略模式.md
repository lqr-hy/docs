# 策略模式

- 策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，将每个算法封装起来，并使它们可以互相替换，使得算法可以独立于客户端而变化。

  1. **策略接口（Strategy Interface）：** 定义了所有支持的算法的公共接口。通常是一个接口或抽象类。
  2. **具体策略（Concrete Strategies）：** 实现了策略接口，并提供了具体的算法实现。
  3. **上下文（Context）：** 持有一个策略对象的引用，用于调用具体的算法。上下文可以接收客户端的请求，并将请求委派给策略对象。

1. **_优点：_**

   - **算法独立性：** 策略模式将每个算法封装在单独的类中，使得每个算法可以独立于其他算法而变化，从而提高了代码的灵活性和可维护性。
   - **易于扩展：** 策略模式使得新的算法可以很容易地添加到系统中，而不需要修改现有的代码，符合开闭原则。
   - **避免使用条件语句：** 策略模式消除了大量的条件语句，使得代码更加清晰和易于理解。
   - **提高可读性：** 将算法封装在单独的类中，使得代码更加模块化，易于理解和维护。

2. **_缺点：_**

   - **增加类的数量：** 每个具体策略都需要一个单独的类，可能会增加系统中类的数量，使得系统变得更加复杂。
   - **客户端必须了解所有的策略：** 客户端必须了解所有的具体策略类，才能正确地选择合适的策略，可能会增加客户端的复杂性。

3. **_使用场景：_**

   - **多算法替换：** 当一个系统需要多个算法并且需要在运行时动态地选择其中一个算法时，可以使用策略模式。例如，不同的排序算法、不同的加密算法等。
   - **消除大量的条件语句：** 当一个系统中包含大量的条件语句，根据不同的条件执行不同的操作时，可以考虑使用策略模式来消除这些条件语句，使得代码更加清晰和易于理解。
   - **具有相似行为的类：** 当一组类只有算法或行为上的不同，并且需要动态地在这些类之间切换时，可以使用策略模式。例如，不同类型的动物都有不同的叫声，可以使用策略模式来实现。
   - **需要在运行时动态地选择算法：** 当需要根据用户的输入或者系统的状态来选择不同的算法时，可以使用策略模式。例如，根据用户选择的支付方式来计算不同的折扣。


:::info 策略模式和状态模式区别
策略模式（Strategy Pattern）和状态模式（State Pattern）虽然都属于行为型设计模式，但它们之间有一些重要的区别。

1. **目的：**
   - **策略模式：** 主要目的是封装一组可以互相替换的算法，并使它们可以独立于客户端而变化。策略模式注重的是算法的选择和切换。
   - **状态模式：** 主要目的是封装一组与对象的状态相关的行为，并使对象在不同状态下具有不同的行为。状态模式注重的是对象状态的切换和行为的封装。

2. **关注点：**
   - **策略模式：** 关注于算法的选择和使用，客户端需要显式地选择并传递一个特定的策略对象给上下文。
   - **状态模式：** 关注于对象的状态变化，客户端通常不直接指定状态，而是通过内部状态的变化来触发不同的行为。

3. **适用场景：**
   - **策略模式：** 适用于需要在运行时根据不同的情况选择不同的算法的情况，以及需要消除大量的条件语句的情况。
   - **状态模式：** 适用于需要将对象的行为根据状态进行封装，并且状态之间存在转换的情况。当一个对象的行为取决于它的状态，并且该状态可以在运行时改变时，可以考虑使用状态模式。

4. **关系：**
   - **策略模式：** 上下文和具体策略之间存在关联，上下文持有一个策略对象的引用，并通过策略对象来执行算法。
   - **状态模式：** 上下文和具体状态之间存在关联，上下文持有一个状态对象的引用，并通过状态对象来执行行为。状态之间可以相互转换，状态对象之间通常也是相互关联的。

总之，策略模式适用于需要在不同的算法之间切换的情况，而状态模式适用于需要根据对象状态改变其行为的情况。虽然它们都涉及到行为的封装和对象之间的关联，但它们的关注点和解决的问题是不同的。
:::
:::details demo

```typescript
// 定义策略接口
interface PaymentStrategy {
  pay(amount: number): void
}

// 具体策略：支付宝支付
class AliPayStrategy implements PaymentStrategy {
  pay(amount: number): void {
    console.log(`支付宝支付 ${amount} 元`)
  }
}

// 具体策略：微信支付
class WeChatPayStrategy implements PaymentStrategy {
  pay(amount: number): void {
    console.log(`微信支付 ${amount} 元`)
  }
}

// 上下文：订单
class Order {
  private paymentStrategy: PaymentStrategy

  constructor(paymentStrategy: PaymentStrategy) {
    this.paymentStrategy = paymentStrategy
  }

  setPaymentStrategy(paymentStrategy: PaymentStrategy): void {
    this.paymentStrategy = paymentStrategy
  }

  pay(amount: number): void {
    this.paymentStrategy.pay(amount)
  }
}

// 客户端代码
const order = new Order(new AliPayStrategy()) // 初始时使用支付宝支付

order.pay(100) // 输出：支付宝支付 100 元

order.setPaymentStrategy(new WeChatPayStrategy()) // 切换为微信支付

order.pay(200) // 输出：微信支付 200 元
```

在这个示例中，我们定义了一个 `PaymentStrategy` 接口，表示支付策略，并且有两个具体策略类：`AliPayStrategy` 和 `WeChatPayStrategy`。`Order` 类是上下文类，持有一个 `PaymentStrategy` 对象，并将支付的请求委派给策略对象。客户端可以根据需要动态地切换不同的支付策略，而不需要改变订单类的代码。
:::
