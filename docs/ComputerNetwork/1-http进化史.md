# http 进化史

HTTP（Hypertext Transfer Protocol）是一种用于传输超文本（如 HTML）的应用层协议。它经历了多个版本的进化，以下是 HTTP 的主要版本及其进化史：

1. HTTP/0.9：

   - 发布于 1991 年，是 HTTP 的最早版本。
   - 非常简单，只支持 GET 方法，并且不支持头部信息和响应状态码。
   - 只能传输纯文本，没有实现正式的 HTTP 协议规范。

2. HTTP/1.0：

   - 发布于 1996 年。
   - 引入了多种 HTTP 方法，如 GET、POST、HEAD 等。
   - 支持多种类型的数据传输，如文本、图片、音频等。
   - 使用明文传输，安全性较差。

3. HTTP/1.1：

   - 发布于 1997 年。
   - 改进了 HTTP/1.0 的性能，引入了持久连接、管道化等特性，减少了连接的建立和关闭次数。
   - 支持 Host 头部，使得一个服务器可以提供多个域名的网站服务。
   - 引入了缓存控制、断点续传等功能。

4. HTTP/2.0：

   - 发布于 2015 年。
   - 引入了多路复用（Multiplexing），允许在同一连接上同时发送多个请求和响应，提高了并发性能。
   - 支持头部压缩，减少了冗余数据的传输。
   - 引入了服务器推送（Server Push），服务器可以主动推送客户端所需的资源，加快页面加载速度。
   - 使用二进制传输，解析效率更高。

5. HTTP/3.0：
   - 发布于 2020 年。
   - 使用 QUIC 作为传输协议，取代了 TCP 协议，提高了连接的稳定性和速度。
   - 继续改进了性能，降低了延迟。

### 1、http 1.1 和 http 1.0 区别

1. 持久连接：

   - HTTP/1.0：默认情况下，每个 HTTP 请求都需要在单独的连接上进行，即短连接。每个请求完成后，连接会立即关闭，导致频繁地建立和关闭连接，增加了连接的开销。
   - HTTP/1.1：引入了持久连接（Persistent Connection）的概念，允许在同一连接上发送多个请求和响应，不需要为每个请求重新建立连接，减少了连接的开销，提高了性能。

2. Host 头部：

   - HTTP/1.0：没有 Host 头部，因此一个服务器只能提供一个域名的网站服务。
   - HTTP/1.1：引入了 Host 头部，使得一个服务器可以提供多个域名的网站服务，支持虚拟主机。

3. 缓存控制：

   - HTTP/1.0：没有明确的缓存控制机制，缓存策略较为简单，不能灵活地控制缓存行为。
   - HTTP/1.1：引入了更灵活的缓存控制机制，支持多种缓存策略，如 Cache-Control、ETag 等，提高了缓存的效率。

4. 传输编码：

   - HTTP/1.0：只支持 Content-Length 传输编码方式，即通过 Content-Length 头部指定消息体的长度。
   - HTTP/1.1：引入了分块传输编码（Chunked Transfer Encoding），允许服务器将消息分割成多个块进行传输，提高了传输效率，也支持 Content-Length 传输编码方式。

5. 错误处理：
   - HTTP/1.0：没有明确的错误处理机制，服务器只能通过响应状态码表示请求的成功或失败。
   - HTTP/1.1：引入了更多的响应状态码，更细致地表示不同类型的错误，如 1xx 表示信息响应、2xx 表示成功、3xx 表示重定向、4xx 表示客户端错误、5xx 表示服务器错误等。

### 2、http 2.0 和 http 1.1 区别

1. 多路复用（Multiplexing）：

   - HTTP/1.1：每个 HTTP 请求都需要在单独的连接上进行，导致连接的建立和关闭产生较大的开销。
   - HTTP/2.0：引入了多路复用功能，允许在同一连接上同时发送多个请求和响应，避免了连接建立和关闭的开销，提高了并发性能。

2. 二进制传输（Binary Framing）：

   - HTTP/1.1：采用文本格式传输数据，解析起来较为复杂。
   - HTTP/2.0：引入了二进制传输，将数据分割为二进制帧，使得数据的解析更加高效。

::: details 二进制帧
HTTP/2 将所有通信都分解为更小的消息和帧。每个帧都以二进制格式发送，这些帧可以是不同类型的，例如数据帧、头帧、设置帧等。

### 1. 帧类型

不同的帧类型有不同的作用：

- **HEADERS 帧**：包含 HTTP 请求或响应的头信息。
- **DATA 帧**：包含 HTTP 请求或响应的实体主体。
- **SETTINGS 帧**：用于协商连接参数。

### 简单示例

下面是一个简单的 HTTP/2 帧结构示例：

```plaintext
+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |  Flags (8)    |
+-+-------------+---------------+-----------------+
|R|                 Stream Identifier (31)       |
+=+================================================+.
|                   Frame Payload (*)
+---------------------------------------------------+
```

- **Length**: 帧的长度（24 位）
- **Type**: 帧的类型（8 位）
- **Flags**: 帧的标志（8 位）
- **Stream Identifier**: 流标识符（31 位）

### 二进制帧传输示例

假设我们发送一个 HTTP/2 的 HEADERS 帧，其二进制表示可能如下：

```plaintext
00 00 1A 01 04 00 00 00 01
82 87 84 41 0C 2F 69 6E 64
65 78 2E 68 74 6D 6C 30 85
AE C3 77 1B
```

:::

3. Header 压缩：

   - HTTP/1.1：每次请求和响应都携带相同的头部信息，导致冗余的传输。
   - HTTP/2.0：采用 HPACK 算法对头部信息进行压缩，减少了冗余数据的传输。

::: details 头信息压缩机制
HPACK（Header Compression for HTTP/2）。这种机制大大减少了 HTTP/2 请求和响应中的头信息大小，从而提高了网络传输效率。下面是 HPACK 头信息压缩机制的关键点：

### 1. 静态表（Static Table）

HPACK 规范中定义了一个静态表，其中包含了一些常见的头字段和它们的值。静态表在所有 HTTP/2 连接中是固定的，因此客户端和服务器都知道这个表的内容。这允许非常常见的头字段和值被编码成一个小的整数索引，从而节省带宽。

### 2. 动态表（Dynamic Table）

除了静态表之外，HPACK 还允许在客户端和服务器之间共享一个动态表。动态表的内容在连接的生命周期内可以变化。每次发送头信息时，可以将新的头字段和值添加到动态表中。动态表使用了一个 LRU（Least Recently Used）算法来管理其大小，以限制内存的使用。

### 3. 哈夫曼编码

HPACK 还使用了哈夫曼编码（Huffman Coding）来进一步压缩头字段和值。哈夫曼编码是一种变长编码方法，通过对数据中最常见的符号使用较短的编码，从而减少总体数据的长度。

### 4. 头字段索引（Header Field Indexing）

HPACK 可以通过索引方式引用头字段。发送头字段时，可以通过以下几种方式：

- **完全索引引用**：直接使用静态表或动态表中的索引。
- **不完全索引引用**：仅引用头字段的名称，值则需要另行编码。
- **不使用索引**：直接发送头字段和值，但不将其添加到动态表中。

### 示例

假设有一个常见的 HTTP 请求头：

```
:method: GET
:scheme: https
:authority: www.example.com
:path: /index.html
user-agent: curl/7.54.0
```

使用 HPACK 进行压缩时，过程如下：

1. **静态表索引**：例如，`:method: GET` 在静态表中有一个固定的索引，可以直接引用该索引。
2. **动态表更新**：例如，`user-agent: curl/7.54.0` 可能不是静态表中的常见字段，因此它可能被添加到动态表中供以后使用。
3. **哈夫曼编码**：头字段和值的字符串部分会使用哈夫曼编码进行压缩。

:::

4. 服务器推送（Server Push）：

   - HTTP/1.1：客户端只能通过请求来获取资源，无法主动获取服务器未请求的资源。
   - HTTP/2.0：支持服务器推送功能，服务器可以在发送响应时主动推送客户端所需的其他资源，提高了页面加载速度。

::: details 服务器推送
HTTP/2 服务器推送的工作原理

1. 初始请求：客户端发出一个 HTTP 请求。
2. 服务器响应：服务器响应客户端请求，并且在响应中包含一个或多个 PUSH_PROMISE 帧。
3. PUSH_PROMISE 帧：PUSH_PROMISE 帧告诉客户端，服务器即将推送的资源。这些资源在客户端缓存中不可用，并且客户端可以选择拒绝接收这些资源。
4. 推送资源：服务器开始发送推送的资源，客户端接收这些资源并缓存它们以备后用。
   :::

5. 流量控制：
   - HTTP/1.1：没有流量控制的机制，容易造成服务器和客户端之间的阻塞。
   - HTTP/2.0：引入了流量控制功能，可以控制数据的传输速率，避免了过多的数据积压。

::: details 流量控制
HTTP/2 的流量控制（Flow Control）机制是为了防止发送方占用过多的资源，从而保证网络资源的公平分配和高效使用。它在流级别和连接级别上进行管理，每个级别都有独立的流量控制窗口（Window）。以下是流量控制的详细解释：

### 流量控制机制

1. **流量控制窗口**

   - 每个流和整个连接都有一个流量控制窗口，用于限制接收方允许发送方发送的最大数据量。
   - 窗口大小可以动态调整，初始大小在连接建立时由接收方设置。

2. **WINDOW_UPDATE 帧**
   - 接收方通过发送 `WINDOW_UPDATE` 帧来通知发送方可以发送更多数据。这种帧会增加流量控制窗口的大小。
   - `WINDOW_UPDATE` 帧包含一个 `Window Size Increment` 字段，表示增加的窗口大小。

### 流量控制示例

假设客户端（发送方）和服务器（接收方）之间的流量控制初始设置如下：

- 流量控制窗口大小：65,535 字节（初始值）
- 流 ID 为 1 的流量控制窗口大小：65,535 字节（初始值）

在传输过程中，当接收方消耗了一部分数据之后，需要通知发送方可以继续发送更多数据。

### 操作流程

1. **客户端发送数据**

   - 客户端发送一个 `DATA` 帧，流 ID 为 1，负载大小为 16,000 字节。
   - 流量控制窗口减少 16,000 字节，剩余 49,535 字节。

2. **服务器接收数据并发送 WINDOW_UPDATE**
   - 服务器接收并处理数据，窗口减少到 49,535 字节。
   - 服务器向客户端发送一个 `WINDOW_UPDATE` 帧，流 ID 为 1，`Window Size Increment` 为 16,000 字节。
   - 窗口大小恢复到 65,535 字节。

### 示例代码

下面是一个简化的示例代码，展示如何在 HTTP/2 的客户端和服务器之间实现流量控制：

#### 客户端代码（Node.js HTTP/2）

```javascript
const http2 = require('http2')
const fs = require('fs')

const client = http2.connect('http://localhost:3000')

client.on('connect', () => {
  const req = client.request({ ':path': '/' })

  req.setEncoding('utf8')

  req.on('data', (chunk) => {
    console.log(`Received chunk: ${chunk}`)
  })

  req.on('end', () => {
    console.log('Request ended.')
    client.close()
  })

  // 模拟发送大量数据
  req.write('A'.repeat(16000)) // 发送16,000字节数据
  req.end()
})
```

#### 服务器代码（Node.js HTTP/2）

```javascript
const http2 = require('http2')
const fs = require('fs')

const server = http2.createServer((req, res) => {
  let receivedData = ''

  req.on('data', (chunk) => {
    receivedData += chunk
  })

  req.on('end', () => {
    console.log(`Received data: ${receivedData.length} bytes`)

    // 发送 WINDOW_UPDATE 帧，允许客户端发送更多数据
    res.stream.session.state.localWindowSize += 16000 // 增加窗口大小
    res.stream.windowUpdate(16000)

    res.end('Hello, client!')
  })
})

server.listen(3000, () => {
  console.log('Server listening on port 3000')
})
```

### 流量控制的重要性

流量控制在 HTTP/2 中非常重要，因为它有助于：

- 避免发送方发送过多数据，导致接收方缓冲区溢出。
- 保持网络资源的公平分配，避免单个流占用过多带宽。
- 提高传输效率，保证数据传输的稳定性和可靠性。

:::

### 3、http 3.0 和 http 2.0 区别

1. 传输协议：

   - HTTP/2.0：使用 TCP 协议作为传输层协议。虽然 HTTP/2.0 引入了多路复用等特性，提高了并发性能，但 TCP 协议的一些缺点（如队头阻塞等）仍然存在。
   - HTTP/3.0：使用 QUIC（Quick UDP Internet Connections）协议作为传输层协议。QUIC 是基于 UDP 的新一代传输协议，通过使用 UDP 的数据报传输，解决了 TCP 的队头阻塞等问题，提高了连接的稳定性和速度。

2. 连接建立：

   - HTTP/2.0：在建立连接时需要进行 TCP 三次握手，然后再建立 TLS 连接（如果是 HTTPS），增加了连接建立的时间开销。
   - HTTP/3.0：由于使用 QUIC 协议，连接建立速度更快，无需进行 TCP 三次握手，也可以使用 0-RTT（Zero Round-Trip Time Resumption）来实现更快的连接建立。

3. 多路复用：

   - HTTP/2.0：引入了多路复用特性，允许在同一连接上同时发送多个请求和响应，减少了连接建立和关闭的开销。
   - HTTP/3.0：同样支持多路复用，但由于使用 QUIC 协议，解决了 TCP 的队头阻塞问题，进一步提高了并发性能。

4. 可靠性：
   - HTTP/2.0：在 TCP 连接断开时，需要重新建立连接，可能导致传输中断，需要重新发起请求。
   - HTTP/3.0：由于使用 QUIC 协议，连接断开后可以快速恢复，保持传输的可靠性。
