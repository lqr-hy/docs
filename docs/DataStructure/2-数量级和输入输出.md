# 数量级和输入输出

算法的数量级，也称为算法的时间复杂度和空间复杂度，描述了算法在输入规模增加时对资源（如时间和空间）的需求增长情况。理解算法的数量级有助于评估算法的效率，选择合适的算法来解决实际问题。

### 时间复杂度

时间复杂度描述了算法所需的时间与输入规模之间的关系，常用大 O 符号表示。常见的时间复杂度有：

1. **常数时间复杂度 O(1)**：

   - 算法的执行时间不随输入规模的变化而变化。
   - 示例：访问数组中的某个元素。

2. **对数时间复杂度 O(log n)**：

   - 算法的执行时间随输入规模的对数增长。
   - 示例：二分查找。

3. **线性时间复杂度 O(n)**：

   - 算法的执行时间与输入规模成正比。
   - 示例：线性查找、遍历数组。

4. **线性对数时间复杂度 O(n log n)**：

   - 算法的执行时间与输入规模的乘积成对数增长。
   - 示例：快速排序、归并排序。

5. **平方时间复杂度 O(n^2)**：

   - 算法的执行时间与输入规模的平方成正比。
   - 示例：冒泡排序、选择排序、插入排序。

6. **立方时间复杂度 O(n^3)**：

   - 算法的执行时间与输入规模的立方成正比。
   - 示例：Floyd-Warshall 算法（用于计算所有顶点对的最短路径）。

7. **指数时间复杂度 O(2^n)**：

   - 算法的执行时间随输入规模的指数增长。
   - 示例：解决集合划分问题的递归算法。

8. **阶乘时间复杂度 O(n!)**：
   - 算法的执行时间随输入规模的阶乘增长。
   - 示例：求解旅行商问题的暴力算法。

### 空间复杂度

空间复杂度描述了算法所需的内存空间与输入规模之间的关系，也用大 O 符号表示。常见的空间复杂度有：

1. **常数空间复杂度 O(1)**：

   - 算法所需的空间不随输入规模的变化而变化。
   - 示例：交换两个变量的值。

2. **线性空间复杂度 O(n)**：

   - 算法所需的空间与输入规模成正比。
   - 示例：存储输入数组的副本。

3. **平方空间复杂度 O(n^2)**：
   - 算法所需的空间与输入规模的平方成正比。
   - 示例：存储一个 n x n 的矩阵。

### 示例分析

**示例 1：线性查找**

```js
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i
    }
  }
  return -1
}

// 示例调用
console.log(linearSearch([1, 2, 3, 4, 5], 3)) // 输出: 2
console.log(linearSearch([1, 2, 3, 4, 5], 6)) // 输出: -1
```

- 时间复杂度：O(n)，因为在最坏情况下需要遍历整个数组。
- 空间复杂度：O(1)，因为只使用了常数的额外空间。

**示例 2：快速排序**

```js
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr
  }
  let pivot = arr[Math.floor(arr.length / 2)]
  let left = arr.filter((x) => x < pivot)
  let middle = arr.filter((x) => x === pivot)
  let right = arr.filter((x) => x > pivot)
  return quickSort(left).concat(middle, quickSort(right))
}

// 示例调用
console.log(quickSort([3, 6, 8, 10, 1, 2, 1])) // 输出: [1, 1, 2, 3, 6, 8, 10]
```

- 时间复杂度：O(n log n)（平均情况下），最坏情况下是 O(n^2)。
- 空间复杂度：O(log n)（由于递归调用栈）。

**示例 3：二分查找**

```js
function binarySearch(arr, target) {
  let low = 0,
    high = arr.length - 1
  while (low <= high) {
    let mid = Math.floor((low + high) / 2)
    if (arr[mid] === target) {
      return mid
    } else if (arr[mid] < target) {
      low = mid + 1
    } else {
      high = mid - 1
    }
  }
  return -1
}

// 示例调用
console.log(binarySearch([1, 2, 3, 4, 5], 3)) // 输出: 2
console.log(binarySearch([1, 2, 3, 4, 5], 6)) // 输出: -1
```

- 时间复杂度：O(log n)，因为每次比较后搜索区间减半。
- 空间复杂度：O(1)，因为只使用了常数的额外空间。

### 输入和输出

算法的输入和输出是指算法接受的数据和算法返回的结果。输入规模（n）是衡量算法性能的重要参数。

**示例：斐波那契数列**

```js
function fibonacci(n) {
  if (n <= 1) {
    return n
  }
  return fibonacci(n - 1) + fibonacci(n - 2)
}

// 示例调用
console.log(fibonacci(5)) // 输出: 5
console.log(fibonacci(10)) // 输出: 55
```

- 输入：一个整数 n。
- 输出：斐波那契数列的第 n 项。
- 时间复杂度：O(2^n)，由于大量的重叠子问题。
- 空间复杂度：O(n)，由于递归调用栈的深度。

**优化斐波那契数列（动态规划）**

```js
function fibonacciDP(n) {
  if (n <= 1) {
    return n
  }
  let fib = [0, 1]
  for (let i = 2; i <= n; i++) {
    fib[i] = fib[i - 1] + fib[i - 2]
  }
  return fib[n]
}

// 示例调用
console.log(fibonacciDP(5)) // 输出: 5
console.log(fibonacciDP(10)) // 输出: 55
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)
