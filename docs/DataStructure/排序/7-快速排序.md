# 快速排序

快速排序（Quick Sort）是一种基于分治法（Divide and Conquer）的高效排序算法。它的核心思想是通过一次排序将数组分成两部分，其中一部分的元素都比另一部分的元素小，然后递归地对这两部分分别进行排序。

### 快速排序的核心思想

1. **选择基准（Pivot）**：

   - 从数组中选择一个元素作为基准。

2. **分区（Partition）**：

   - 将数组重新排序，使所有比基准小的元素放在基准的左边，所有比基准大的元素放在基准的右边。

3. **递归排序（Recursively Sort）**：
   - 递归地对基准左边的子数组和基准右边的子数组进行排序。

### 快速排序的步骤

1. 从数组中选择一个基准元素（通常选择第一个、最后一个或中间的元素）。
2. 重新排列数组，所有小于基准的元素放在基准的左边，所有大于基准的元素放在基准的右边（称为分区操作）。
3. 递归地对基准左边和右边的子数组进行排序。

### 快速排序的代码实现

下面是一个 JavaScript 实现的快速排序，并且每一行都有注释解释：

```javascript
function quickSort(arr) {
  // 如果数组长度小于等于1，直接返回数组
  if (arr.length <= 1) return arr

  // 选择基准元素，通常选择中间元素
  const pivot = arr[Math.floor(arr.length / 2)]

  // 定义左右两个数组
  const left = [],
    right = []

  // 遍历数组，将小于基准的元素放在左边，大于基准的元素放在右边
  for (let i = 0; i < arr.length; i++) {
    if (i !== Math.floor(arr.length / 2)) {
      if (arr[i] < pivot) left.push(arr[i])
      else right.push(arr[i])
    }
  }

  // 递归地对左右两个子数组进行排序，并合并
  return quickSort(left).concat(pivot, quickSort(right))
}

// 示例调用
const array = [64, 34, 25, 12, 22, 11, 90]
console.log(quickSort(array)) // 输出: [11, 12, 22, 25, 34, 64, 90]
```

### 代码解释

1. **`if (arr.length <= 1) return arr;`**：

   - 如果数组长度小于等于 1，直接返回数组，因为一个元素或空数组是有序的。

2. **`const pivot = arr[Math.floor(arr.length / 2)];`**：

   - 选择中间元素作为基准。

3. **`const left = [], right = [];`**：

   - 定义左右两个数组，用于存放小于和大于基准的元素。

4. **`for (let i = 0; i < arr.length; i++) { ... }`**：

   - 遍历数组，将小于基准的元素放在左边数组，大于基准的元素放在右边数组。

5. **`return quickSort(left).concat(pivot, quickSort(right));`**：
   - 递归地对左右两个子数组进行排序，并将它们与基准元素合并成一个有序数组。

### 时间复杂度

快速排序的时间复杂度与选择的基准元素有关：

- **最优情况**：\(O(n \log n)\)，每次分区将数组均匀分成两部分。
- **最坏情况**：\(O(n^2)\)，每次分区选择的基准都是最大或最小的元素，导致每次只分一个元素出来。
- **平均情况**：\(O(n \log n)\)，一般情况下快速排序的性能较优。

### 空间复杂度

快速排序的空间复杂度为 \(O(\log n)\)，主要是递归调用栈的空间消耗。

### 总结

- **核心思想**：通过分治法选择基准，将数组分成两部分，递归地对两部分进行排序。
- **时间复杂度**：最优情况和平均情况为 \(O(n \log n)\)，最坏情况为 \(O(n^2)\)。
- **空间复杂度**：\(O(\log n)\)。

快速排序是一种高效且实用的排序算法，适用于大多数情况下的排序任务。通过优化基准选择策略，可以在大多数情况下避免最坏情况的发生。
