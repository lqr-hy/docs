# 归并排序

归并排序（Merge Sort）是一种基于分治法（Divide and Conquer）的高效排序算法。它的核心思想是将数组递归地分成两个子数组，分别对两个子数组进行排序，然后将排好序的子数组合并成一个有序的数组。

### 归并排序的核心思想

1. **分解（Divide）**：

   - 将数组从中间分成两个子数组，递归地对这两个子数组进行分解，直到每个子数组只包含一个元素。

2. **解决（Conquer）**：

   - 递归地将每个子数组排序。

3. **合并（Combine）**：
   - 将两个排好序的子数组合并成一个有序的数组。

### 归并排序的步骤

1. **递归分解**：

   - 不断将数组对半分解，直到每个子数组只包含一个元素。

2. **合并排序**：
   - 将两个排好序的子数组合并成一个有序的数组，重复这个过程直到整个数组排序完成。

### 归并排序的代码实现

下面是一个 JavaScript 实现的归并排序，并且每一行都有注释解释：

```javascript
function mergeSort(arr) {
  // 如果数组长度小于等于1，直接返回数组
  if (arr.length <= 1) {
    return arr
  }

  // 找到数组的中间位置
  const mid = Math.floor(arr.length / 2)

  // 递归地分解左半部分数组
  const left = mergeSort(arr.slice(0, mid))

  // 递归地分解右半部分数组
  const right = mergeSort(arr.slice(mid))

  // 合并已排序的两个子数组
  return merge(left, right)
}

function merge(left, right) {
  const result = []

  // 使用两个指针遍历两个子数组
  while (left.length && right.length) {
    // 比较两个子数组的第一个元素
    if (left[0] <= right[0]) {
      // 将较小的元素推入结果数组
      result.push(left.shift())
    } else {
      // 将较小的元素推入结果数组
      result.push(right.shift())
    }
  }

  // 将剩余的元素推入结果数组
  return result.concat(left, right)
}

// 示例调用
const array = [38, 27, 43, 3, 9, 82, 10]
console.log(mergeSort(array)) // 输出: [3, 9, 10, 27, 38, 43, 82]
```

### 代码解释

1. **`if (arr.length <= 1) { return arr; }`**：

   - 如果数组长度小于等于 1，直接返回数组，因为一个元素或空数组是有序的。

2. **`const mid = Math.floor(arr.length / 2);`**：

   - 找到数组的中间位置，将数组分成两半。

3. **`const left = mergeSort(arr.slice(0, mid));`**：

   - 递归地对左半部分数组进行排序。

4. **`const right = mergeSort(arr.slice(mid));`**：

   - 递归地对右半部分数组进行排序。

5. **`return merge(left, right);`**：

   - 合并两个已排序的子数组。

6. **`function merge(left, right) { ... }`**：

   - 合并两个已排序的子数组。

7. **`const result = [];`**：

   - 创建一个结果数组。

8. **`while (left.length && right.length) { ... }`**：

   - 使用两个指针遍历两个子数组，比较它们的第一个元素，将较小的元素推入结果数组。

9. **`result.push(left.shift());` 和 `result.push(right.shift());`**：

   - 将较小的元素推入结果数组，并从原数组中移除。

10. **`return result.concat(left, right);`**：
    - 将剩余的元素推入结果数组。

### 时间复杂度

归并排序的时间复杂度为 \(O(n \log n)\)，因为它总是将问题对半分解，并且在合并过程中需要线性时间。

### 空间复杂度

归并排序的空间复杂度为 \(O(n)\)，因为它需要额外的数组来存储合并的结果。

### 总结

- **核心思想**：通过分治法将数组分解成较小的子数组，分别排序后再合并成一个有序数组。
- **时间复杂度**：最坏情况、最优情况和平均情况均为 \(O(n \log n)\)。
- **空间复杂度**：\(O(n)\)，需要额外的存储空间来合并数组。

归并排序是一种稳定的排序算法，适用于对大型数组进行排序。
