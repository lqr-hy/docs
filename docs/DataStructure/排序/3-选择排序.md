# 选择排序

选择排序（Selection Sort）是一种简单直观的排序算法。它的核心思想是每次从未排序部分中选择最小的元素，放到已排序部分的末尾，从而逐步将整个数组排序。

### 选择排序的核心思想

1. **选择最小元素**：
   - 从未排序部分中找到最小（或最大）的元素。
2. **交换位置**：

   - 将这个最小（或最大）的元素与未排序部分的第一个元素交换位置。

3. **重复步骤**：
   - 每次选择未排序部分中的最小（或最大）元素，逐步将其放到已排序部分的末尾。
   - 重复上述步骤，直到所有元素均已排序。

### 选择排序的步骤

1. 从数组的第一个元素开始，找到整个数组中最小的元素，将它与第一个元素交换位置。
2. 从第二个元素开始，找到剩余元素中最小的元素，将它与第二个元素交换位置。
3. 以此类推，直到数组完全有序。

### 选择排序的代码实现

下面是一个 JavaScript 实现的选择排序，并且每一行都有注释解释：

```javascript
function selectionSort(arr) {
  let n = arr.length

  // 外层循环遍历数组
  for (let i = 0; i < n - 1; i++) {
    let minIndex = i // 假设当前下标的元素是最小值

    // 内层循环寻找最小值
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j // 更新最小值的下标
      }
    }

    // 将最小值与当前位置交换
    if (minIndex !== i) {
      ;[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
    }
  }

  return arr // 返回排序后的数组
}

// 示例调用
const array = [64, 25, 12, 22, 11]
console.log(selectionSort(array)) // 输出: [11, 12, 22, 25, 64]
```

### 代码解释

1. **`let n = arr.length;`**：

   - 获取数组的长度 `n`。

2. **`for (let i = 0; i < n - 1; i++)`**：

   - 外层循环遍历数组，从第一个元素到倒数第二个元素。

3. **`let minIndex = i;`**：

   - 假设当前元素 `arr[i]` 是未排序部分中的最小值，记录其下标 `minIndex`。

4. **`for (let j = i + 1; j < n; j++)`**：

   - 内层循环从 `i+1` 开始，遍历未排序部分寻找最小值。

5. **`if (arr[j] < arr[minIndex])`**：

   - 如果找到比 `arr[minIndex]` 更小的元素，更新 `minIndex`。

6. **`[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];`**：

   - 将最小值 `arr[minIndex]` 与当前元素 `arr[i]` 交换位置。

7. **`return arr;`**：
   - 返回排序后的数组。

### 时间复杂度

选择排序的时间复杂度与数据的初始状态无关，始终为 \(O(n^2)\)：

- **外层循环**：进行 \(n-1\) 次迭代。
- **内层循环**：第一次进行 \(n-1\) 次比较，第二次进行 \(n-2\) 次比较，依次类推，直到最后一次进行 1 次比较。
- **总的比较次数**：\(1 + 2 + 3 + ... + (n-1) = \frac{n(n-1)}{2}\)，时间复杂度为 \(O(n^2)\)。

### 空间复杂度

选择排序的空间复杂度为 \(O(1)\)，只需要常数级别的额外空间。

### 总结

- **核心思想**：通过选择未排序部分中的最小（或最大）元素，将其逐步放到已排序部分的末尾。
- **时间复杂度**：\(O(n^2)\)，与数据的初始状态无关。
- **空间复杂度**：\(O(1)\)，只需要常数级别的额外空间。

选择排序简单直观，适用于小规模数据的排序，但在数据量较大时效率较低。
