# 桶排序

桶排序（Bucket Sort）是一种排序算法，它将待排序数组分到有限数量的桶中，每个桶再分别进行排序（可以使用其他排序算法或递归地使用桶排序），最后将所有非空桶的元素串接起来即可得到排序结果。

### 桶排序的核心思想

1. **分桶**：

   - 将待排序数组划分为若干个大小相等的子区间（桶）。

2. **排序**：

   - 对每个桶中的元素进行排序。可以选择不同的排序算法，如插入排序、快速排序等。

3. **合并**：
   - 将各个桶中排好序的元素按顺序合并成最终的排序结果。

### 桶排序的步骤

1. **确定桶的数量**：

   - 根据待排序数组的特性和范围，确定需要多少个桶以及每个桶的范围。

2. **分配元素到桶中**：

   - 遍历待排序数组，将每个元素放入相应的桶中。

3. **对每个桶中的元素排序**：

   - 对每个非空桶中的元素进行排序。

4. **合并桶中的元素**：
   - 按照桶的顺序和每个桶内元素的顺序，将元素依次放回原数组中，得到排序后的数组。

### 桶排序的代码实现

下面是一个简单的 JavaScript 实现桶排序，并带有注释解释每一行的作用：

```javascript
function bucketSort(arr, bucketSize = 5) {
  if (arr.length === 0) {
    return arr // 如果数组为空，直接返回
  }

  const min = Math.min(...arr)
  const max = Math.max(...arr)

  // 计算桶的数量
  const bucketCount = Math.floor((max - min) / bucketSize) + 1
  const buckets = new Array(bucketCount)

  // 初始化桶
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = []
  }

  // 将元素分配到各个桶中
  for (let i = 0; i < arr.length; i++) {
    const bucketIndex = Math.floor((arr[i] - min) / bucketSize)
    buckets[bucketIndex].push(arr[i])
  }

  // 对每个桶中的元素进行排序，并合并为结果数组
  const sortedArr = []
  for (let i = 0; i < bucketCount; i++) {
    if (buckets[i]) {
      insertionSort(buckets[i]) // 这里使用插入排序对每个桶进行排序
      sortedArr.push(...buckets[i])
    }
  }

  return sortedArr
}

// 辅助函数：插入排序
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let current = arr[i]
    let j = i - 1
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j]
      j--
    }
    arr[j + 1] = current
  }
}

// 示例调用
const array = [29, 25, 3, 49, 9, 37, 21, 43]
console.log(bucketSort(array)) // 输出: [3, 9, 21, 25, 29, 37, 43, 49]
```

### 代码解释

1. **`function bucketSort(arr, bucketSize = 5) { ... }`**：

   - 主函数，桶排序的入口函数。
   - 根据数组的最小值和最大值计算需要多少个桶，初始化桶数组。
   - 将元素分配到各个桶中，然后对每个桶中的元素进行排序，并合并为最终的排序结果。

2. **`const min = Math.min(...arr); const max = Math.max(...arr);`**：

   - 找出数组中的最小值和最大值，用于计算桶的范围。

3. **`const bucketCount = Math.floor((max - min) / bucketSize) + 1;`**：

   - 计算需要的桶的数量。

4. **`const buckets = new Array(bucketCount);`**：

   - 初始化桶数组。

5. **`for (let i = 0; i < arr.length; i++) { ... }`**：

   - 将元素分配到各个桶中。

6. **`for (let i = 0; i < bucketCount; i++) { ... }`**：
   - 对每个桶中的元素进行排序（这里使用插入排序）并合并为最终的排序结果。

### 时间复杂度

桶排序的时间复杂度取决于桶的数量和每个桶内使用的排序算法。假设使用的排序算法是 \(O(n \log n)\)，那么桶排序的时间复杂度为 \(O(n \log n)\)。

### 空间复杂度

桶排序的空间复杂度主要取决于额外的存储空间，即桶数组和排序算法使用的空间。如果桶的数量合理控制，空间复杂度可以为 \(O(n + k)\)，其中 \(k\) 是桶的数量。

### 总结

- **核心思想**：将待排序数组分配到多个桶中，每个桶分别排序，然后按顺序合并。
- **时间复杂度**：取决于桶的数量和排序算法的性能。
- **空间复杂度**：取决于桶的数量和额外的存储空间。

桶排序适用于数据分布均匀的情况下，可以有效地提高排序的效率。
