# 基数排序

基数排序（Radix Sort）是一种非比较型整数排序算法，它按照数字的每一位进行排序，从最低有效位（个位）到最高有效位（最高位）。基数排序可以用于整数或字符串的排序，但是它对于整数的排序更为常见。

### 基数排序的核心思想

基数排序的核心思想是通过将待排序的数字按照位数（从低位到高位或者从高位到低位）分配到桶中，然后按照桶的顺序依次将数字取出，再重复这个过程，直到所有位数都处理完毕，最终得到排序后的结果。

### 基数排序的步骤

1. **确定排序的位数**：

   - 确定待排序数字的最大位数，这决定了需要进行多少轮排序。

2. **分配到桶中**：

   - 从最低有效位开始（或者从最高有效位开始），将数字按照当前位的值分配到对应的桶中。

3. **收集桶中的元素**：

   - 将每个桶中的元素按顺序收集起来，形成新的排序数组。

4. **重复操作**：
   - 重复以上步骤，直到所有位数都处理完毕。

### 基数排序的代码实现

以下是一个基于 JavaScript 的基数排序的实现，并带有详细的注释解释每一行代码的作用：

```javascript
function radixSort(arr) {
  const max = Math.max(...arr) // 找出数组中的最大值

  let exp = 1
  while (Math.floor(max / exp) > 0) {
    // 根据最大值确定位数，从低位到高位依次进行排序
    countingSort(arr, exp) // 调用计数排序对当前位数进行排序
    exp *= 10 // 移向更高位
  }

  return arr
}

// 辅助函数：计数排序，按照指定位数进行排序
function countingSort(arr, exp) {
  const n = arr.length
  const output = new Array(n).fill(0)
  const count = new Array(10).fill(0)

  for (let i = 0; i < n; i++) {
    const digit = Math.floor(arr[i] / exp) % 10 // 获取当前位数的数字
    count[digit]++ // 统计当前位数的数字出现次数
  }

  for (let i = 1; i < 10; i++) {
    count[i] += count[i - 1] // 将计数数组转换为累加计数数组
  }

  for (let i = n - 1; i >= 0; i--) {
    const digit = Math.floor(arr[i] / exp) % 10
    output[count[digit] - 1] = arr[i] // 根据累加计数数组，将元素放置到输出数组中的正确位置
    count[digit]--
  }

  for (let i = 0; i < n; i++) {
    arr[i] = output[i] // 将输出数组复制回原数组
  }
}

// 示例调用
const array = [170, 45, 75, 90, 802, 24, 2, 66]
console.log(radixSort(array)) // 输出: [2, 24, 45, 66, 75, 90, 170, 802]
```

### 代码解释

1. **`function radixSort(arr) { ... }`**：

   - 主函数，基数排序的入口函数。
   - 找出数组中的最大值，确定需要排序的位数，然后依次调用计数排序对每一位进行排序。

2. **`let exp = 1; while (Math.floor(max / exp) > 0) { ... }`**：

   - 根据数组中的最大值确定需要排序的位数，从低位到高位依次进行排序。

3. **`function countingSort(arr, exp) { ... }`**：
   - 辅助函数，计数排序，按照指定位数（`exp`）进行排序。
   - 创建计数数组 `count` 来统计每个数字在当前位上的出现次数。
   - 将计数数组转换为累加计数数组，并根据累加计数数组将元素放置到输出数组 `output` 中的正确位置。
   - 最后将输出数组复制回原数组 `arr`。

### 时间复杂度

基数排序的时间复杂度取决于位数和排序算法（通常使用的是计数排序），在位数较少时可以达到线性时间复杂度 \(O(nk)\)，其中 \(n\) 是数组的长度，\(k\) 是数字的位数。

### 空间复杂度

基数排序的空间复杂度主要取决于额外的存储空间，主要是计数数组和输出数组，因此空间复杂度为 \(O(n + k)\)，其中 \(k\) 是数字的位数。

### 总结

- **核心思想**：按照数字的每一位进行排序，从低位到高位或从高位到低位，直到所有位数都处理完毕。
- **时间复杂度**：取决于位数和使用的排序算法。
- **空间复杂度**：取决于额外的存储空间，主要是计数数组和输出数组。

基数排序适用于整数排序，特别是当待排序数字的位数相对较小且范围确定时，它能够提供稳定且高效的排序结果。
