# 堆排序

堆排序（Heap Sort）是一种基于堆数据结构的比较排序算法。堆是一种近似完全二叉树的结构，并满足堆性质：对于最大堆，任何一个父节点的值都大于或等于其子节点的值；对于最小堆，任何一个父节点的值都小于或等于其子节点的值。

### 堆排序的核心思想

1. **构建堆**：

   - 将待排序的数组构建成一个最大堆（或最小堆）。

2. **排序**：
   - 将堆顶元素与堆的最后一个元素交换，将堆的尺寸减少 1，然后重新调整堆，使其再次满足堆性质。重复此过程，直到堆的尺寸为 1。

### 堆排序的步骤

1. **构建最大堆**：

   - 从最后一个非叶子节点开始，依次向上调整堆，使其满足最大堆性质。

2. **交换堆顶元素与最后一个元素，并调整堆**：
   - 将堆顶元素与最后一个元素交换，将堆的尺寸减少 1，然后重新调整堆，确保剩余部分仍然是最大堆。重复此过程直到堆的尺寸为 1。

### 堆排序的代码实现

下面是一个 JavaScript 实现的堆排序，并且每一行都有注释解释：

```javascript
// 主函数：堆排序
function heapSort(arr) {
  // 构建最大堆
  buildMaxHeap(arr)

  // 堆排序
  for (let i = arr.length - 1; i > 0; i++) {
    // 交换堆顶元素与最后一个元素
    ;[arr[0], arr[i]] = [arr[i], arr[0]]
    // 调整堆，使其满足最大堆性质
    heapify(arr, 0, i)
  }

  return arr // 返回排序后的数组
}

// 构建最大堆
function buildMaxHeap(arr) {
  // 从最后一个非叶子节点开始，依次向上调整堆
  for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {
    heapify(arr, i, arr.length)
  }
}

// 调整堆，使其满足最大堆性质
function heapify(arr, index, heapSize) {
  let largest = index // 假设当前节点是最大的
  const left = 2 * index + 1 // 左子节点索引
  const right = 2 * index + 2 // 右子节点索引

  // 如果左子节点存在且大于当前节点，则更新最大值索引
  if (left < heapSize && arr[left] > arr[largest]) {
    largest = left
  }

  // 如果右子节点存在且大于当前节点，则更新最大值索引
  if (right < heapSize && arr[right] > arr[largest]) {
    largest = right
  }

  // 如果最大值索引不是当前节点，则交换并继续调整
  if (largest !== index) {
    ;[arr[index], arr[largest]] = [arr[largest], arr[index]]
    heapify(arr, largest, heapSize) // 递归调整子树
  }
}

// 示例调用
const array = [64, 34, 25, 12, 22, 11, 90]
console.log(heapSort(array)) // 输出: [11, 12, 22, 25, 34, 64, 90]
```

### 代码解释

1. **`function heapSort(arr) { ... }`**：

   - 主函数，执行堆排序的步骤。
   - 调用 `buildMaxHeap(arr)` 构建最大堆。
   - 遍历数组，将堆顶元素与最后一个元素交换，并调整堆。

2. **`function buildMaxHeap(arr) { ... }`**：

   - 从最后一个非叶子节点开始，依次向上调整堆，使其满足最大堆性质。

3. **`function heapify(arr, index, heapSize) { ... }`**：

   - 调整堆，使其满足最大堆性质。
   - 比较当前节点与其左子节点和右子节点的值，如果子节点的值较大，则交换并递归调整子树。

4. **`for (let i = arr.length - 1; i > 0; i--) { ... }`**：

   - 从数组的最后一个元素开始，将堆顶元素与当前元素交换，并调整堆。

5. **`[arr[0], arr[i]] = [arr[i], arr[0]];`**：

   - 交换堆顶元素与当前元素。

6. **`heapify(arr, 0, i);`**：
   - 调整堆，使其满足最大堆性质。

### 时间复杂度

堆排序的时间复杂度为 \(O(n \log n)\)：

- **构建最大堆**：\(O(n)\)
- **调整堆（heapify）**：每次调整堆的时间复杂度为 \(O(\log n)\)，调整 \(n\) 次

### 空间复杂度

堆排序的空间复杂度为 \(O(1)\)，只需要常数级别的额外空间。

### 总结

- **核心思想**：通过构建最大堆，反复将堆顶元素与最后一个元素交换并调整堆，直到整个数组有序。
- **时间复杂度**：最优情况、最坏情况和平均情况均为 \(O(n \log n)\)。
- **空间复杂度**：\(O(1)\)。

堆排序是一种高效的原地排序算法，适用于不要求稳定排序的场景。它的性能在大多数情况下与快速排序相当，但在最坏情况下，堆排序具有更好的时间复杂度。
