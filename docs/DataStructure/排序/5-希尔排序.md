# 希尔排序

希尔排序（Shell Sort）是插入排序的一种改进版，它通过比较距离较远的元素来进行排序。希尔排序的核心思想是先将整个数组分割成若干子数组分别进行插入排序，以使得整个数组大致有序，最后再对全体进行一次直接插入排序。

### 希尔排序的核心思想

1. **分组排序**：

   - 将数组按一定的步长（gap）进行分组，对每组分别进行插入排序。

2. **逐步缩小步长**：

   - 每次将步长缩小，逐步对整个数组进行排序。

3. **最终步长为 1**：
   - 当步长缩小到 1 时，进行一次完整的插入排序，此时整个数组已经基本有序，插入排序效率较高。

### 希尔排序的步骤

1. 选择一个步长序列，通常初始步长为数组长度的一半。
2. 按步长对数组进行分组，对每组分别进行插入排序。
3. 缩小步长，重复步骤 2，直到步长为 1。
4. 最后一次插入排序，使整个数组有序。

### 希尔排序的代码实现

下面是一个 JavaScript 实现的希尔排序，并且每一行都有注释解释：

```javascript
function shellSort(arr) {
  let n = arr.length

  // 初始步长设为数组长度的一半
  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {
    // 从gap开始，对每个元素进行插入排序
    for (let i = gap; i < n; i++) {
      let temp = arr[i]
      let j
      // 对每组元素进行插入排序
      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
        arr[j] = arr[j - gap]
      }
      arr[j] = temp
    }
  }

  return arr // 返回排序后的数组
}

// 示例调用
const array = [64, 34, 25, 12, 22, 11, 90]
console.log(shellSort(array)) // 输出: [11, 12, 22, 25, 34, 64, 90]
```

### 代码解释

1. **`let n = arr.length;`**：

   - 获取数组的长度 `n`。

2. **`for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2))`**：

   - 初始化步长 `gap` 为数组长度的一半，每次循环将步长缩小一半，直到步长为 1。

3. **`for (let i = gap; i < n; i++)`**：

   - 从下标为 `gap` 的元素开始遍历数组。

4. **`let temp = arr[i];`**：

   - 保存当前元素 `temp`。

5. **`for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)`**：

   - 对每组元素进行插入排序，找到当前元素 `temp` 应该插入的位置。
   - 如果前一个元素大于 `temp`，则将前一个元素向后移动 `gap` 个位置。

6. **`arr[j] = temp;`**：

   - 将 `temp` 插入到正确的位置。

7. **`return arr;`**：
   - 返回排序后的数组。

### 时间复杂度

希尔排序的时间复杂度取决于步长序列的选择，通常最坏情况为 \(O(n^2)\)，但在实际应用中，希尔排序的性能往往优于 \(O(n^2)\)。常见的步长序列有以下几种：

- **原始希尔序列**：gap = n/2, n/4, ..., 1
- **Hibbard 序列**：gap = 1, 3, 7, ..., 2^k - 1
- **Knuth 序列**：gap = 1, 4, 13, ..., (3^k - 1)/2

### 空间复杂度

希尔排序的空间复杂度为 \(O(1)\)，只需要常数级别的额外空间。

### 总结

- **核心思想**：通过逐步缩小步长对数组进行分组插入排序，使得数组大致有序，最后进行一次完整的插入排序。
- **时间复杂度**：取决于步长序列，通常最坏情况为 \(O(n^2)\)，但实际性能往往优于 \(O(n^2)\)。
- **空间复杂度**：\(O(1)\)，只需要常数级别的额外空间。

希尔排序通过分组排序和逐步缩小步长，改进了插入排序的性能，使其在实际应用中效率更高。
