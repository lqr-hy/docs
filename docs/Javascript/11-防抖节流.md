# 防抖和节流

**防抖（Debounce）** 和 **节流（Throttle）** 是两种常见的性能优化手段，主要用于限制函数的执行频率，特别是在高频事件（如滚动、输入、窗口调整大小）中，避免多次触发事件对页面性能造成影响。

### 1. 防抖（Debounce）

**原理**：防抖是一种将多次频繁触发的操作合并为一次的技术。在一定时间间隔内多次触发函数时，只有最后一次触发会被执行。适用于如输入搜索框实时查询、窗口大小调整等场景。

#### 实现方法

通过设置一个计时器，在一定时间内如果继续触发函数，则会清除之前的计时器，重新计时，直到规定时间内不再触发，才执行函数。

#### 代码示例

```javascript
function debounce(func, delay) {
  let timer
  return function (...args) {
    const context = this
    clearTimeout(timer) // 清除上一次的计时器
    timer = setTimeout(() => {
      func.apply(context, args) // 延迟执行函数
    }, delay)
  }
}

// 使用示例
window.addEventListener(
  'resize',
  debounce(() => {
    console.log('Resize event debounced!')
  }, 300)
)
```

在此例中，只有在窗口大小调整停止 300 毫秒后，`resize` 回调才会执行。

#### 适用场景

- **搜索框输入**：在用户停止输入时再触发查询，避免每次按键都进行一次请求。
- **窗口调整**：只在调整完成后执行一次操作，而不是连续触发事件。
- **按钮点击**：避免用户快速连续点击，防止重复提交表单。

### 2. 节流（Throttle）

**原理**：节流是限制函数的执行频率，保证函数在指定时间内至多只会执行一次。适合于持续性、高频率的触发操作，例如滚动页面、滚动加载、鼠标移动等事件。

#### 实现方法

使用一个时间戳或定时器，每次触发函数时检查时间间隔是否已到，如果到达指定时间则执行函数，否则忽略当前触发，等待下次间隔。

#### 代码示例

```javascript
function throttle(func, limit) {
  let lastFunc
  let lastRan
  return function (...args) {
    const context = this
    if (!lastRan) {
      // 首次立即执行
      func.apply(context, args)
      lastRan = Date.now()
    } else {
      clearTimeout(lastFunc) // 清除上一次的定时器
      lastFunc = setTimeout(function () {
        if (Date.now() - lastRan >= limit) {
          func.apply(context, args)
          lastRan = Date.now()
        }
      }, limit - (Date.now() - lastRan))
    }
  }
}

// 使用示例
window.addEventListener(
  'scroll',
  throttle(() => {
    console.log('Scroll event throttled!')
  }, 200)
)
```

在此例中，`scroll` 事件会被限制在 200 毫秒内执行一次，即使在该时间间隔内事件多次触发也不会被执行。

#### 适用场景

- **页面滚动**：在滚动事件中触发动画或加载更多内容。
- **鼠标移动**：用于限制 `mousemove` 事件的触发频率。
- **按钮点击**：限制短时间内的连续点击，避免多次触发同一事件。

### 3. 防抖与节流的区别

| 特性     | 防抖（Debounce）             | 节流（Throttle）                     |
| -------- | ---------------------------- | ------------------------------------ |
| 执行方式 | 一段时间不触发才执行最后一次 | 一段时间内只会执行一次               |
| 场景     | 输入框、搜索框防抖查询       | 滚动、拖拽、页面滚动加载等高频事件   |
| 触发频率 | 规定时间内触发一次           | 连续触发时，在规定时间内最多执行一次 |

### 4. 综合使用

在实际应用中，可以根据需求选择使用防抖或节流，甚至结合两者来优化性能。例如在搜索框中，既可以防抖（减少多次请求）又可以限制查询频率（节流）。

#### 例子

```javascript
const handleSearch = debounce(() => {
  console.log('Search triggered!')
}, 500)

const handleScroll = throttle(() => {
  console.log('Scroll triggered!')
}, 100)

window.addEventListener('input', handleSearch)
window.addEventListener('scroll', handleScroll)
```

通过防抖和节流，可以显著减少高频触发事件对性能的影响，提升应用的流畅度和响应速度。
