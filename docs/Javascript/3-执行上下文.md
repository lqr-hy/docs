# 执行上下文（EC）

>   执行上下文可以简单理解为一个对象

*   它包含**三部分**
    *   变量对象（VO）
    *   作用域链（词法作用域）
    *   this 指向

*   它的**类型**：
    *   全局执行上下文
    *   函数执行上下文
    *   eval 执行上下文

*   代码执行**过程**：
    *   创建 **全局上下文**（global EC）
    *   全局执行上下文（caller）**自上而下** 逐行执行。遇到函数时，**函数执行上下文**（callee）被 push 到执行栈顶
    *   函数执行上下文被激活，成为 active EC，开始执行函数中的代码，caller 被挂起
    *   函数执行完后，callee 被 pop 移除出执行栈，控制权交还给全局上下文（caller）继续执行



### 1、变量对象

变量对象是执行上下文中的一部分，可以抽象为一种 **数据作用域**，其实也可以理解为就是一个简单的对象，他存储遮盖执行上下文中所有的 **变量和函数声明（不包含函数表达式）**

>   活动对象（AO）：当变量对象所处的上下文为 active EC 时，被称为活动对象


### 2、作用域

执行上下文中还包含作用域链。

作用域可以理解为该上下文中声明的 **变量和声明的作用范围**，可分为 **块级作用域** 和 **函数作用域**
JavaScript 采用词法作用域（lexical scoping），也就是静态作用域。


特性：

*   **声明提前**：一个声明在函数体内都是可见的，函数优先于变量
*   非匿名自执行函数，函数变量为 **只读** 状态，无法修改

```javascript
let foo = function() { console.log(1) };
(function foo() {
  foo = 10 // 由于 foo 在函数中是只读的，因此赋值无效
  console.log(foo)
}())
// 结果打印：  ƒ foo() { foo = 10 ; console.log(foo) }
```

#### 1、 静态作用域与动态作用域

因为 JavaScript 采用的是词法作用域，因此函数的作用域在函数定义的时候就已经确定了。

而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

下面这个例子可以帮你分清楚两者的区别：

```js
var value = 1

function foo() {
  console.log(value)
}

function bar() {
  var value = 2
  foo()
}

bar()

// 结果是1
```

因为 JS 采用的是静态作用域，所以编译器在初次运行代码之前，会先自上而下遍历一遍所有代码，当进入 foo 函数的时候，它会首先查找是否存在局部变量 value，没有则继续往外查找直至全局。

#### 2、动态作用域

动态作用域和静态作用域相反，一旦进入函数之后发现没有局部变量，不是直接往外查找，而是通过调用关系去一层层往外寻找。

>   JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。



### 3、作用域链

作用域链使得我们可以在执行上下文中访问父级甚至全局的变量。作用域链可以理解为一组对象列表，包含 **父级和自身的变量对象**，它由两部分组成：

*   [[scope]] 属性：指向父级变量对象和作用域链，也就是包含了父级的 [[scope]] 和 AO
*   AO：自身活动对象

如此，便形成一条自上而下的 **链式作用域**


### 4、闭包

闭包属于一种特殊的作用域，称之为 **静态作用域**。他的定义可以理解为：**父函数被销毁** 的情况下，返回的子函数的 [[scope]] 中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称之为闭包

#### 1、闭包的作用

*   外部可以读取函数内部的变量
*   让函数内部的变量一直保持不被销毁

#### 2、经典问题

>   多个子函数的 [[scope]] 都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响

解决：

*   变量可以通过 **函数参数的形式** 传入，避免使用默认的 [[scope]] 向上查找
*   使用 setTimeout 包裹，通过第三个参数传入
*   使用 **块级作用域**，让变量成为自己上下文的属性，避免共享


### 4、垃圾回收机制

>   垃圾回收：将内存中不再使用的数据进行清理，释放内存空间。
>
>   V8 将内存分为 **新生代空间** 和 **老生代空间**

#### 1、新生代空间

>   用于存活较短的对象

*   又分为两个空间：from 空间和 to 空间
*   Scavenge GC 算法：当 from 空间被占满时，启动 GC 算法
    *   存活的对象从 from 空间转移到 to 空间
    *   清空 from 空间
    *   from 空间和 to 空间互换
    *   完成一次新生代 GC

#### 2、老生代空间

>   用于存活较长的对象

*   从新生代空间转移到老生代空间的条件
    *   经历一次以上 Scavenge GC 的对象
    *   当 to 空间体积超过25%
*   **标记清除算法**：标记存活的对象，未被标记的则被释放
    *   增量标记：小模块标记，在代码执行间隙执行，GC 会影响性能
    *   并发标记（最新技术）：不阻塞 JS 执行
*   **压缩算法**：将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 **内存碎片化**


#### 3、内存泄漏

*   意外的 **全局变量**：无法被回收
*   **定时器**：未被正确关闭，导致所引用的外部变量无法被释放
*   **事件监听**：没有正确销毁（低版本浏览器可能出现）
*   **闭包**：会导致父级中的变量无法被释放
*   **dom 引用**：dom 元素被删除时，内存中的引用未被正确清空
