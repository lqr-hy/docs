# Vue 2 和 3 依赖收集区别

在 Vue 的响应式系统中，依赖收集（Dependency Collection）是核心步骤，它将需要自动更新的部分（如视图渲染或计算属性）与响应式数据关联起来，以便在数据变更时，系统可以自动触发这些依赖的更新。

### Vue 2 的依赖收集

在 Vue 2 中，依赖收集主要通过 `Watcher` 和 `Dep` 这两个核心类来实现，整个过程分为以下几步：

1. **初始化阶段创建 Watcher**：

   - 当组件渲染或计算属性被初始化时，Vue 会为每个响应式数据创建一个 `Watcher` 实例，`Watcher` 用于记录组件或计算属性的依赖关系。
   - 组件中的每个数据绑定都关联一个 `Watcher`，每个计算属性也会对应一个独立的 `Watcher`。

2. **访问数据触发 getter，收集依赖**：

   - 在数据被访问时（即执行到 getter 中），会触发 `Dep` 对象的 `depend` 方法。此时 `Dep` 会检查当前是否存在活跃的 `Watcher`，并将它添加到当前 `Dep` 的依赖列表中。
   - `Dep` 是一个依赖管理器，它负责追踪一个响应式数据的依赖 `Watcher` 列表。`Dep` 将依赖收集后，建立数据和 `Watcher` 之间的关联。

3. **依赖关联**：
   - 每个响应式属性都持有一个 `Dep` 实例。`Dep` 将当前属性依赖的所有 `Watcher` 收集起来，以便在数据更新时触发这些 `Watcher` 重新执行。
   - `Watcher` 也会反向存储与其相关的 `Dep`，这样当 `Watcher` 被销毁时，也可以从这些 `Dep` 的依赖列表中移除，避免内存泄漏。

### Vue 3 的依赖收集

Vue 3 使用 `Proxy` 代理对象属性，监听访问操作，实现响应式数据的依赖收集。Vue 3 引入了 **Reactive Effect**（反应式副作用）的概念，依赖收集的过程如下：

1. **Reactive Effect 的定义**：

   - Vue 3 使用 `effect` 函数来注册副作用（Effect），每个 `effect` 就是一个需要响应式追踪的依赖项。
   - 当访问响应式数据时，Vue 3 会将当前的 `effect` 函数记录下来，等同于 Vue 2 中的 `Watcher`。

2. **访问属性触发依赖收集**：

   - 在 Vue 3 中，当访问响应式对象的某个属性时，触发 `Proxy` 的 `get` 拦截器，Vue 会将当前的 `effect` 函数记录到该属性的依赖集合中。
   - Vue 3 使用 `Map` 结构保存依赖数据：一级 `Map` 的 key 是响应式对象，二级 `Map` 的 key 是对象的属性，value 是依赖该属性的 `effect` 函数的集合。

3. **存储依赖和派发更新**：
   - 每个响应式属性都存有一个依赖它的 `effect` 集合。
   - 当该属性值发生改变时，Vue 3 会触发 `set` 拦截器，找到该属性的 `effect` 集合，并重新执行所有依赖此属性的 `effect` 函数。

### Vue 2 和 Vue 3 依赖收集的区别

| 特性         | Vue 2                          | Vue 3                          |
| ------------ | ------------------------------ | ------------------------------ |
| 实现方式     | `Watcher` 与 `Dep`             | `effect` 和 `Map` 数据结构     |
| 数据劫持     | `Object.defineProperty`        | `Proxy`                        |
| 收集过程     | 通过 `getter` 注册 `Watcher`   | 通过 `get` 拦截器注册 `effect` |
| 性能和灵活性 | 数据劫持递归遍历对象，性能较低 | `Proxy` 可直接监听嵌套属性     |

### 总结

Vue 的依赖收集机制确保了数据和视图的同步更新。Vue 2 通过 `Watcher` 和 `Dep` 进行依赖收集和追踪，而 Vue 3 通过 `Proxy` 和 `effect` 进一步简化了依赖收集，提升了性能和灵活性。Vue 3 的依赖收集系统基于 `Map` 数据结构，能够处理更复杂的场景，支持更高效的依赖管理。
