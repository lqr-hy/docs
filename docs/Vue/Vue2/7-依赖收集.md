# 依赖收集

1. 函数通过定义对象属性的 getter 和 setter 来实现响应式属性。getter 用于依赖收集，setter 用于在属性值变化时通知依赖更新。

```ts
// 在对象上定义一个响应式属性。
export function defineReactive(
  obj: object,
  key: string,
  val?: any,
  customSetter?: Function | null,
  shallow?: boolean,
  mock?: boolean,
  observeEvenIfShallow = false
) {
  const dep = new Dep() // 依赖收集器

  const property = Object.getOwnPropertyDescriptor(obj, key) // 获取obj[key]的属性描述符
  if (property && property.configurable === false) {
    return
  }

  // 适应预定义的getter/setter
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && (val === NO_INITIAL_VALUE || arguments.length === 2)) {
    val = obj[key]
  }

  let childOb = shallow ? val && val.__ob__ : observe(val, false, mock) // 检测数据的变化
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        if (__DEV__) {
          dep.depend({
            target: obj,
            type: TrackOpTypes.GET,
            key
          })
        } else {
          dep.depend() // 依赖收集
        }
        if (childOb) {
          // 如果childOb存在
          childOb.dep.depend() // 依赖收集
          if (isArray(value)) {
            // 如果value是数组
            dependArray(value) // 依赖收集
          }
        }
      }
      return isRef(value) && !shallow ? value.value : value
    },
    set: function reactiveSetter(newVal) {
      const value = getter ? getter.call(obj) : val
      if (!hasChanged(value, newVal)) {
        // 判断新值和旧值是否相等
        return
      }
      if (__DEV__ && customSetter) {
        customSetter()
      }
      if (setter) {
        setter.call(obj, newVal)
      } else if (getter) {
        // #7981: for accessor properties without setter
        return
      } else if (!shallow && isRef(value) && !isRef(newVal)) {
        value.value = newVal
        return
      } else {
        val = newVal
      }
      childOb = shallow ? newVal && newVal.__ob__ : observe(newVal, false, mock)
      if (__DEV__) {
        dep.notify({
          type: TriggerOpTypes.SET,
          target: obj,
          key,
          newValue: newVal,
          oldValue: value
        })
      } else {
        dep.notify() // 通知依赖更新
      }
    }
  })

  return dep
}
```

### 1、Dep

1. 用户管理 `watcher`
   - `target` 全局唯一的 `watcher`
   - `subs` 是一个 `watcher` 数组

```ts
default class Dep {
  static target?: DepTarget | null
  id: number
  subs: Array<DepTarget | null> // 订阅者列表
  _pending = false // 是否正在清理订阅者

  constructor() {
    this.id = uid++
    this.subs = []
  }

  addSub(sub: DepTarget) { // 添加订阅者
    this.subs.push(sub)
  }

  removeSub(sub: DepTarget) { // 移除订阅者，并将其标记为 null，推送到 pendingCleanupDeps 中
    this.subs[this.subs.indexOf(sub)] = null
    if (!this._pending) {
      this._pending = true
      pendingCleanupDeps.push(this)
    }
  }

  depend(info?: DebuggerEventExtraInfo) { // 将当前观察者添加到依赖项的订阅者列表中
    if (Dep.target) {
      Dep.target.addDep(this)
      if (__DEV__ && info && Dep.target.onTrack) {
        Dep.target.onTrack({
          effect: Dep.target,
          ...info
        })
      }
    }
  }

  notify(info?: DebuggerEventExtraInfo) { // 通知所有订阅者进行更新
    // 规范订阅者列表
    const subs = this.subs.filter(s => s) as DepTarget[]
    if (__DEV__ && !config.async) {
      // 如果不是异步运行，则调度程序中的订阅者未排序 我们现在需要对它们进行排序以确保它们按正确的顺序触发
      subs.sort((a, b) => a.id - b.id)
    }
    for (let i = 0, l = subs.length; i < l; i++) {
      const sub = subs[i]
      if (__DEV__ && info) {
        sub.onTrigger &&
          sub.onTrigger({
            effect: subs[i],
            ...info
          })
      }
      sub.update()
    }
  }
}

// 当前目标观察者正在评估。 这是全局唯一的，因为一次只能评估一个观察者
Dep.target = null
const targetStack: Array<DepTarget | null | undefined> = []

export function pushTarget(target?: DepTarget | null) {
  targetStack.push(target)
  Dep.target = target
}

export function popTarget() {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}
```

### 2、Watcher

1. 初始化和获取值：

   - 在构造函数中，watcher 会根据是否是懒加载（lazy）来决定是否立即获取值。
   - 如果不是懒加载，watcher 会调用 get() 方法来获取初始值。

2. 评估 getter 并重新收集依赖：

   - get() 方法会调用 getter 函数来获取值，并在此过程中收集依赖。
   - pushTarget(this) 和 popTarget() 用于设置和清除当前的 Dep.target，以便在 getter 执行时收集依赖。
   - 如果 watcher 是深度监听（deep），则会遍历值以确保所有属性都被追踪为依赖。

3. 错误处理：

   - 在 get() 方法中，如果 getter 执行过程中发生错误，会根据 watcher 的类型（用户 watcher 或内部 watcher）进行不同的错误处理。

4. 清理依赖：

   - 在 get() 方法的 finally 块中，调用 cleanupDeps() 方法来清除依赖。

5. 添加依赖：

   - addDep(dep: Dep) 方法用于将依赖添加到当前的 watcher 中。

```ts
// watcher解析表达式，收集依赖项，并在表达式值更改时触发回调。 用于$watch() api和指令。
export default class Watcher implements DepTarget {
  vm?: Component | null
  expression: string
  cb: Function
  id: number
  deep: boolean
  user: boolean
  lazy: boolean
  sync: boolean
  dirty: boolean
  active: boolean
  deps: Array<Dep>
  newDeps: Array<Dep>
  depIds: SimpleSet
  newDepIds: SimpleSet
  before?: Function
  onStop?: Function
  noRecurse?: boolean
  getter: Function
  value: any
  post: boolean

  // dev only
  onTrack?: ((event: DebuggerEvent) => void) | undefined
  onTrigger?: ((event: DebuggerEvent) => void) | undefined

  constructor(
    vm: Component | null,
    expOrFn: string | (() => any),
    cb: Function,
    options?: WatcherOptions | null,
    isRenderWatcher?: boolean
  ) {
    recordEffectScope(
      // 记录effect作用域
      this,
      // if the active effect scope is manually created (not a component scope),
      // prioritize it
      activeEffectScope && !activeEffectScope._vm ? activeEffectScope : vm ? vm._scope : undefined
    )
    if ((this.vm = vm) && isRenderWatcher) {
      // 如果是渲染watcher
      vm._watcher = this
    }
    // options
    if (options) {
      this.deep = !!options.deep // 是否深度监听
      this.user = !!options.user // 是否是用户watcher
      this.lazy = !!options.lazy // 是否是懒watcher
      this.sync = !!options.sync // 是否是同步watcher
      this.before = options.before // 在更新之前执行的函数
      if (__DEV__) {
        this.onTrack = options.onTrack
        this.onTrigger = options.onTrigger
      }
    } else {
      this.deep = this.user = this.lazy = this.sync = false // 默认都是false
    }
    this.cb = cb // 回调函数
    this.id = ++uid // uid for batching 用于批处理的uid
    this.active = true // 是否激活
    this.post = false // 是否是post
    this.dirty = this.lazy // for lazy watchers 是否是懒watcher
    this.deps = [] // 依赖
    this.newDeps = [] // 新依赖
    this.depIds = new Set() // 依赖id
    this.newDepIds = new Set() // 新依赖id
    this.expression = __DEV__ ? expOrFn.toString() : ''
    // parse expression for getter
    if (isFunction(expOrFn)) {
      // 如果是函数
      this.getter = expOrFn // getter是expOrFn
    } else {
      this.getter = parsePath(expOrFn) // 解析路径
      if (!this.getter) {
        this.getter = noop // 如果没有getter则是空函数
        __DEV__ &&
          warn(
            `Failed watching path: "${expOrFn}" ` +
              'Watcher only accepts simple dot-delimited paths. ' +
              'For full control, use a function instead.',
            vm
          )
      }
    }
    this.value = this.lazy ? undefined : this.get() // 如果是懒watcher则是undefined，否则是get()的值
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   * 评估getter，并重新收集依赖项。
   */
  get() {
    pushTarget(this) // 设置当前watcher为Dep.target
    let value
    const vm = this.vm // 获取vm
    try {
      value = this.getter.call(vm, vm) // 获取getter的值
    } catch (e: any) {
      if (this.user) {
        // 如果是用户watcher
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        // 如果是深度监听
        traverse(value) // 遍历value
      }
      popTarget() // 设置Dep.target为null
      this.cleanupDeps() // 清除依赖
    }
    return value
  }

  /**
   * Add a dependency to this directive.
   * 添加依赖
   */
  addDep(dep: Dep) {
    const id = dep.id // 获取id
    if (!this.newDepIds.has(id)) {
      // 如果新依赖id没有id
      this.newDepIds.add(id) // 添加id
      this.newDeps.push(dep) // 添加dep
      if (!this.depIds.has(id)) {
        // 如果依赖id没有id
        dep.addSub(this) // 添加sub
      }
    }
  }

  /**
   * Clean up for dependency collection.
   * 清理依赖
   */
  cleanupDeps() {
    let i = this.deps.length // 获取deps的长度
    while (i--) {
      // 遍历deps
      const dep = this.deps[i] // 获取dep
      if (!this.newDepIds.has(dep.id)) {
        // 如果新依赖id没有dep.id
        dep.removeSub(this) // 移除sub
      }
    }
    let tmp: any = this.depIds // 交换depIds和newDepIds
    this.depIds = this.newDepIds // 交换depIds和newDepIds
    this.newDepIds = tmp // 交换depIds和newDepIds
    this.newDepIds.clear() // 清空newDepIds
    tmp = this.deps // 交换deps和newDeps
    this.deps = this.newDeps // 交换deps和newDeps
    this.newDeps = tmp // 交换deps和newDeps
    this.newDeps.length = 0 // 清空newDeps
  }

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   * 订阅者接口。 当依赖项更改时将调用它。
   */
  update() {
    /* istanbul ignore else */
    if (this.lazy) {
      // 如果是懒watcher
      this.dirty = true // 设置dirty为true
    } else if (this.sync) {
      // 如果是同步watcher
      this.run() // 执行run
    } else {
      // 如果是异步watcher
      queueWatcher(this) // 添加到队列
    }
  }

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   * 执行watcher
   */
  run() {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // 如果value不等于this.value或者value是对象或者是深度监听
        // set new value
        const oldValue = this.value // 获取旧值
        this.value = value // 设置新值
        if (this.user) {
          const info = `callback for watcher "${this.expression}"` // 获取信息
          invokeWithErrorHandling(
            // 调用错误处理
            this.cb,
            this.vm,
            [value, oldValue],
            this.vm,
            info
          )
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  evaluate() {
    // 评估watcher的值
    this.value = this.get() // 获取值
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   * 依赖于此观察者收集的所有依赖项。
   */
  depend() {
    // 依赖
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  /**
   * Remove self from all dependencies' subscriber list.
   * 移除自己的依赖
   */
  teardown() {
    if (this.vm && !this.vm._isBeingDestroyed) {
      remove(this.vm._scope.effects, this)
    }
    if (this.active) {
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
      if (this.onStop) {
        this.onStop()
      }
    }
  }
}
```

### 3、派发更新的过程

```shell
dep.notify()
  ↓
watcher 的 update方法
  ↓
queueWatcher(this)
  ↓
queue.push(watcher)
  ↓
nextTick(flushSchedulerQueue)
```

```ts
// 将一个观察者推入观察者队列 具有重复ID的作业将被跳过，除非在刷新队列时推送。 该队列会在 nextTick 时执行 flushSchedulerQueue 方法
export function queueWatcher(watcher: Watcher) {
  const id = watcher.id
  if (has[id] != null) {
    // 如果已经存在
    return
  }

  if (watcher === Dep.target && watcher.noRecurse) {
    // 如果 watcher 是 Dep.target 并且 watcher 不递归
    return
  }

  has[id] = true // 设置为 true
  if (!flushing) {
    // 如果没有在刷新
    queue.push(watcher) // 推入队列
  } else {
    // 如果已经在刷新，则根据其 id 切割 watcher 如果已经超过其 id，则立即运行
    let i = queue.length - 1
    while (i > index && queue[i].id > watcher.id) {
      i--
    }
    queue.splice(i + 1, 0, watcher)
  }
  // 如果没有等待，则等待
  if (!waiting) {
    waiting = true

    if (__DEV__ && !config.async) {
      flushSchedulerQueue()
      return
    }
    nextTick(flushSchedulerQueue)
  }
}

// 刷新队列并运行观察者
function flushSchedulerQueue() {
  currentFlushTimestamp = getNow() // 获取当前时间戳
  flushing = true
  let watcher, id

  // 在刷新之前对队列进行排序。 这确保：
  // 1. 组件从父级更新到子级。 （因为父级总是在子级之前创建）
  // 2. 组件的用户观察者在其渲染观察者之前运行（因为用户观察者在渲染观察者之前创建）
  // 3. 如果在父组件的观察者运行期间销毁了组件，则可以跳过其观察者。
  queue.sort(sortCompareFn)

  // 不要缓存长度，因为在运行现有观察者时可能会推送更多观察者
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index] // 获取观察者
    if (watcher.before) {
      watcher.before() // 如果有 before 方法，则运行
    }
    id = watcher.id
    has[id] = null
    watcher.run() // 运行观察者
    // 如果在开发环境中，检查并停止循环更新
    if (__DEV__ && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' +
            (watcher.user
              ? `in watcher with expression "${watcher.expression}"`
              : `in a component render function.`),
          watcher.vm
        )
        break
      }
    }
  }

  // 在重置状态之前保留 post 队列的副本
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  // 重置调度程序状态
  resetSchedulerState()

  // 调用组件更新和激活钩子
  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue) // 调用更新钩子
  cleanupDeps() // 清理依赖

  // 如果在开发环境中，检查并停止循环更新
  if (devtools && config.devtools) {
    devtools.emit('flush')
  }
}

function callUpdatedHooks(queue: Watcher[]) {
  let i = queue.length
  while (i--) {
    const watcher = queue[i]
    const vm = watcher.vm
    if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated')
    }
  }
}

// 将在补丁期间激活的 keep-alive 组件推入队列。 该队列将在整个树被打补丁后处理。
export function queueActivatedComponent(vm: Component) {
  // 设置_inactive为false，以便渲染函数可以依赖于检查它是否在非活动树中（例如router-view）
  vm._inactive = false
  activatedChildren.push(vm)
}

function callActivatedHooks(queue) {
  for (let i = 0; i < queue.length; i++) {
    queue[i]._inactive = true
    activateChildComponent(queue[i], true /* true */) // 激活子组件
  }
}
```

### 4、nextTick

1. 定义和初始化：

   - 定义了一些全局变量和常量，如 `callbacks`（存储回调函数的数组）、`pending`（标志是否有回调函数待执行）等。
   - 定义了 `flushCallbacks` 函数，用于执行并清空 `callbacks` 数组中的所有回调函数。

2. 选择合适的异步执行方法：

   - 根据当前环境，选择合适的异步执行方法（微任务或宏任务）来执行回调函数。优先使用 `Promise.then`，其次是 `MutationObserver`，然后是 `setImmediate`，最后是 `setTimeout`。
   - 通过 `timerFunc` 函数来封装具体的异步执行方法。

3. 实现 nextTick 函数：

   - `nextTick` 函数有多个重载版本，可以接受不同的参数组合（回调函数和上下文）。
   - 当调用 `nextTick` 时，会将回调函数推入 `callbacks` 数组，并通过 timerFunc 异步执行这些回调函数。
   - 如果没有传入回调函数且支持 `Promise`，则返回一个 `Promise`，以便在回调函数执行完毕后进行链式调用。

4. 错误处理：

   - 在执行回调函数时，如果发生错误，会调用 `handleError` 函数进行错误处理。

```ts
let isUsingMicroTask = false

const callbacks: Array<Function> = []
let pending = false

function flushCallbacks() {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

let timerFunc

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
} else if (
  !isIE &&
  typeof MutationObserver !== 'undefined' &&
  (isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]')
) {
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else {
  // Fallback to setTimeout.
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}

export function nextTick(): Promise<void>
export function nextTick<T>(this: T, cb: (this: T, ...args: any[]) => any): void
export function nextTick<T>(cb: (this: T, ...args: any[]) => any, ctx: T): void
/**
 * @internal
 */
export function nextTick(cb?: (...args: any[]) => any, ctx?: object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e: any) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
```