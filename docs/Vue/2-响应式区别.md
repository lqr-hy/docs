# Vue 2 和 3 响应式区别

在 Vue.js 中，响应式数据的实现是框架的核心功能之一，使得视图能自动响应数据的变化。Vue 通过响应式系统实现了数据和视图的双向绑定。Vue 2 和 Vue 3 的响应式系统实现机制有所不同，Vue 3 引入了 Proxy，以提供更强大和灵活的响应式支持。

### Vue 2 的响应式系统

Vue 2 使用 `Object.defineProperty` 来实现响应式数据。这种方法通过劫持对象的属性读写操作，添加 getter 和 setter 方法来实现响应式数据追踪。

#### Vue 2 的响应式原理

1. **数据劫持**：Vue 2 对每个数据属性使用 `Object.defineProperty` 重新定义 getter 和 setter，监听每个属性的变化。
2. **依赖收集**：在 getter 中收集依赖，把需要更新的组件视图（watcher）与数据属性关联起来。
3. **派发更新**：当数据发生变化时，触发 setter，通知相关依赖（watcher）重新计算并更新视图。

#### 局限性

- **属性监听的限制**：`Object.defineProperty` 只能劫持已有的属性，无法监听新增或删除的属性。因此，Vue 2 中使用 `Vue.set` 来动态添加属性。
- **数组监听的限制**：Vue 2 通过重写数组的变更方法（如 `push`、`pop` 等）来监听数组变化，但无法监听数组索引的直接更改（如直接修改 `arr[1]`），因此需要用 `splice` 等方法。
- **性能瓶颈**：Vue 2 的响应式系统会递归遍历对象的所有属性进行劫持，对大对象有性能影响。

### Vue 3 的响应式系统

Vue 3 使用 `Proxy` 替代 `Object.defineProperty` 来实现响应式数据，克服了 Vue 2 的局限性，使得响应式系统更为灵活和高效。

#### Vue 3 的响应式原理

1. **Proxy 劫持**：Vue 3 使用 `Proxy` 来劫持整个对象，而非逐个属性，能监听新增和删除的属性，动态性更强。
2. **响应式的 Track 和 Trigger 机制**：
   - **Track（依赖收集）**：当访问对象属性时，Vue 3 会记录属性和依赖（视图渲染或计算属性），以便追踪属性的访问。
   - **Trigger（派发更新）**：当属性发生改变时，Vue 3 会通知与该属性相关的依赖进行更新。
3. **Reactive API**：Vue 3 提供了 `reactive` 和 `ref` 等 API，允许手动定义响应式数据，让开发者能更灵活地管理数据响应性。

#### 优势

- **新增/删除属性支持**：`Proxy` 能监控属性的添加和删除，弥补了 `Object.defineProperty` 的局限性。
- **数组和嵌套对象监听优化**：`Proxy` 可以直接监听数组索引和嵌套对象的修改，性能和灵活性更好。
- **模块化和组合式 API**：Vue 3 的响应式 API（如 `reactive` 和 `ref`）让响应式系统更加模块化，方便组合式 API 的使用和数据逻辑复用。

### Vue 2 和 Vue 3 响应式的对比

| 特性              | Vue 2                      | Vue 3                           |
| ----------------- | -------------------------- | ------------------------------- |
| 实现方式          | `Object.defineProperty`    | `Proxy`                         |
| 属性新增/删除监听 | 需要使用 `Vue.set`         | 原生支持                        |
| 数组索引的修改    | 不能直接监听               | 支持直接监听                    |
| 性能              | 深度递归劫持，性能稍低     | `Proxy` 劫持整体对象，性能更高  |
| 响应式 API        | 无（响应式绑定为默认行为） | 提供 `reactive` 和 `ref` 等 API |
| 代码逻辑复用      | Options API                | Composition API                 |

### 总结

Vue 2 的响应式系统基于 `Object.defineProperty`，适合简单场景，但存在一定的局限性；Vue 3 基于 `Proxy` 的响应式系统不仅更强大，而且与 Composition API 结合，使得代码更加灵活和模块化，大幅提升了开发体验。
